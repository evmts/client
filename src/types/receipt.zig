//! Transaction Receipt and Log types
//! Port of erigon/execution/types/receipt.go and log.go

const std = @import("std");
const primitives = @import("primitives");
const Address = primitives.Address;
const Hash = primitives.Hash;
const U256 = primitives.U256;
const rlp = @import("primitives").rlp;
const Bloom = @import("block.zig").Bloom;

/// Receipt status codes
pub const RECEIPT_STATUS_FAILED: u64 = 0;
pub const RECEIPT_STATUS_SUCCESSFUL: u64 = 1;

/// Log represents a contract log event
/// Generated by the LOG opcode and stored/indexed by the node
pub const Log = struct {
    // Consensus fields (secured by consensus)
    /// Address of the contract that generated the event
    address: Address,
    /// List of topics provided by the contract
    topics: []Hash,
    /// Data supplied by the contract (usually ABI-encoded)
    data: []const u8,

    // Derived fields (filled in by the node, not secured by consensus)
    /// Block number in which the transaction was included
    block_number: u64,
    /// Hash of the transaction
    tx_hash: Hash,
    /// Index of the transaction in the block
    tx_index: u32,
    /// Hash of the block in which the transaction was included
    block_hash: Hash,
    /// Index of the log in the block
    index: u32,
    /// True if this log was reverted due to a chain reorganization
    removed: bool,

    pub fn init(address: Address) Log {
        return .{
            .address = address,
            .topics = &[_]Hash{},
            .data = &[_]u8{},
            .block_number = 0,
            .tx_hash = Hash.zero(),
            .tx_index = 0,
            .block_hash = Hash.zero(),
            .index = 0,
            .removed = false,
        };
    }

    pub fn clone(self: Log, allocator: std.mem.Allocator) !Log {
        const topics_copy = try allocator.dupe(Hash, self.topics);
        errdefer allocator.free(topics_copy);

        const data_copy = try allocator.dupe(u8, self.data);
        errdefer allocator.free(data_copy);

        return .{
            .address = self.address,
            .topics = topics_copy,
            .data = data_copy,
            .block_number = self.block_number,
            .tx_hash = self.tx_hash,
            .tx_index = self.tx_index,
            .block_hash = self.block_hash,
            .index = self.index,
            .removed = self.removed,
        };
    }

    pub fn deinit(self: *Log, allocator: std.mem.Allocator) void {
        if (self.topics.len > 0) {
            allocator.free(self.topics);
        }
        if (self.data.len > 0) {
            allocator.free(self.data);
        }
    }

    /// Encode log to RLP (consensus fields only)
    pub fn encode(self: Log, allocator: std.mem.Allocator) ![]u8 {
        var encoder = rlp.Encoder.init(allocator);
        defer encoder.deinit();

        try encoder.startList();
        try encoder.writeBytes(&self.address.bytes);

        try encoder.startList();
        for (self.topics) |topic| {
            try encoder.writeBytes(&topic.bytes);
        }
        try encoder.endList();

        try encoder.writeBytes(self.data);
        try encoder.endList();

        return try encoder.toOwnedSlice();
    }
};

/// Receipt represents the results of a transaction
pub const Receipt = struct {
    // Consensus fields (defined by Yellow Paper)
    /// Transaction type (0 = legacy, 1 = access list, 2 = dynamic fee, 3 = blob, 4 = set code)
    tx_type: u8,
    /// Post-transaction state root (pre-Byzantium)
    post_state: ?[]const u8,
    /// Status code: 0 = failure, 1 = success (post-Byzantium)
    status: u64,
    /// Cumulative gas used in the block up to and including this transaction
    cumulative_gas_used: u64,
    /// Bloom filter for log events
    bloom: Bloom,
    /// Log entries created during transaction execution
    logs: []Log,

    // Implementation fields (added during processing, stored in chain database)
    /// Hash of the transaction
    tx_hash: Hash,
    /// Address of the contract created (if contract creation)
    contract_address: ?Address,
    /// Gas used by this specific transaction
    gas_used: u64,
    /// Blob gas used (EIP-4844)
    blob_gas_used: u64,

    // Inclusion information
    /// Hash of the block containing this transaction
    block_hash: Hash,
    /// Number of the block containing this transaction
    block_number: U256,
    /// Index of the transaction in the block
    transaction_index: u32,

    /// Index of first log within the block (for efficient storage)
    first_log_index_within_block: u32,

    pub fn init() Receipt {
        return .{
            .tx_type = 0,
            .post_state = null,
            .status = RECEIPT_STATUS_SUCCESSFUL,
            .cumulative_gas_used = 0,
            .bloom = Bloom.zero(),
            .logs = &[_]Log{},
            .tx_hash = Hash.zero(),
            .contract_address = null,
            .gas_used = 0,
            .blob_gas_used = 0,
            .block_hash = Hash.zero(),
            .block_number = U256.zero(),
            .transaction_index = 0,
            .first_log_index_within_block = 0,
        };
    }

    /// Create a new receipt with given status and cumulative gas
    pub fn new(failed: bool, cumulative_gas_used: u64) Receipt {
        var receipt = init();
        receipt.cumulative_gas_used = cumulative_gas_used;
        receipt.status = if (failed) RECEIPT_STATUS_FAILED else RECEIPT_STATUS_SUCCESSFUL;
        return receipt;
    }

    pub fn clone(self: Receipt, allocator: std.mem.Allocator) !Receipt {
        var post_state_copy: ?[]const u8 = null;
        if (self.post_state) |ps| {
            post_state_copy = try allocator.dupe(u8, ps);
        }
        errdefer if (post_state_copy) |ps| allocator.free(ps);

        const logs_copy = try allocator.alloc(Log, self.logs.len);
        errdefer allocator.free(logs_copy);

        var i: usize = 0;
        errdefer {
            for (logs_copy[0..i]) |*log| {
                log.deinit(allocator);
            }
        }

        for (self.logs, 0..) |log, idx| {
            logs_copy[idx] = try log.clone(allocator);
            i += 1;
        }

        return .{
            .tx_type = self.tx_type,
            .post_state = post_state_copy,
            .status = self.status,
            .cumulative_gas_used = self.cumulative_gas_used,
            .bloom = self.bloom,
            .logs = logs_copy,
            .tx_hash = self.tx_hash,
            .contract_address = self.contract_address,
            .gas_used = self.gas_used,
            .blob_gas_used = self.blob_gas_used,
            .block_hash = self.block_hash,
            .block_number = self.block_number,
            .transaction_index = self.transaction_index,
            .first_log_index_within_block = self.first_log_index_within_block,
        };
    }

    pub fn deinit(self: *Receipt, allocator: std.mem.Allocator) void {
        if (self.post_state) |ps| {
            allocator.free(ps);
        }
        for (self.logs) |*log| {
            log.deinit(allocator);
        }
        if (self.logs.len > 0) {
            allocator.free(self.logs);
        }
    }

    /// Encode receipt to RLP
    pub fn encode(self: Receipt, allocator: std.mem.Allocator) ![]u8 {
        var encoder = rlp.Encoder.init(allocator);
        defer encoder.deinit();

        // Encode consensus fields
        try encoder.startList();

        // Post-state or status (post-Byzantium uses status)
        if (self.post_state) |ps| {
            try encoder.writeBytes(ps);
        } else {
            // Status as bytes (0 = empty, 1 = [0x01])
            if (self.status == RECEIPT_STATUS_SUCCESSFUL) {
                try encoder.writeBytes(&[_]u8{0x01});
            } else {
                try encoder.writeBytes(&[_]u8{});
            }
        }

        try encoder.writeInt(self.cumulative_gas_used);
        try encoder.writeBytes(&self.bloom.bytes);

        // Logs
        try encoder.startList();
        for (self.logs) |log| {
            const log_bytes = try log.encode(allocator);
            defer allocator.free(log_bytes);
            // Write the RLP-encoded log as raw bytes (already RLP encoded)
            try encoder.writeRaw(log_bytes);
        }
        try encoder.endList();

        try encoder.endList();

        const payload = try encoder.toOwnedSlice();
        errdefer allocator.free(payload);

        // For typed transactions (type > 0), prepend type byte
        if (self.tx_type > 0) {
            var result = try allocator.alloc(u8, 1 + payload.len);
            result[0] = self.tx_type;
            @memcpy(result[1..], payload);
            allocator.free(payload);
            return result;
        }

        return payload;
    }

    /// Check if transaction was successful
    pub fn isSuccessful(self: Receipt) bool {
        return self.status == RECEIPT_STATUS_SUCCESSFUL;
    }

    /// Check if transaction failed
    pub fn isFailed(self: Receipt) bool {
        return self.status == RECEIPT_STATUS_FAILED;
    }
};

/// Collection of receipts
pub const Receipts = struct {
    receipts: []Receipt,

    pub fn init() Receipts {
        return .{ .receipts = &[_]Receipt{} };
    }

    pub fn deinit(self: *Receipts, allocator: std.mem.Allocator) void {
        for (self.receipts) |*receipt| {
            receipt.deinit(allocator);
        }
        if (self.receipts.len > 0) {
            allocator.free(self.receipts);
        }
    }
};

// Tests
test "Log - init and clone" {
    const testing = std.testing;

    const addr = Address.zero();
    var log = Log.init(addr);
    defer log.deinit(testing.allocator);

    log.block_number = 100;
    log.tx_index = 5;

    const cloned = try log.clone(testing.allocator);
    defer {
        var mut_cloned = cloned;
        mut_cloned.deinit(testing.allocator);
    }

    try testing.expect(log.address.eql(cloned.address));
    try testing.expectEqual(log.block_number, cloned.block_number);
    try testing.expectEqual(log.tx_index, cloned.tx_index);
}

test "Receipt - init and status" {
    const testing = std.testing;

    var receipt = Receipt.init();
    defer receipt.deinit(testing.allocator);

    try testing.expect(receipt.isSuccessful());
    try testing.expect(!receipt.isFailed());

    receipt.status = RECEIPT_STATUS_FAILED;
    try testing.expect(receipt.isFailed());
    try testing.expect(!receipt.isSuccessful());
}

test "Receipt - new with status" {
    const testing = std.testing;

    var success_receipt = Receipt.new(false, 21000);
    defer success_receipt.deinit(testing.allocator);
    try testing.expect(success_receipt.isSuccessful());
    try testing.expectEqual(@as(u64, 21000), success_receipt.cumulative_gas_used);

    var failed_receipt = Receipt.new(true, 21000);
    defer failed_receipt.deinit(testing.allocator);
    try testing.expect(failed_receipt.isFailed());
}

test "Receipt - clone" {
    const testing = std.testing;

    var receipt = Receipt.init();
    receipt.gas_used = 21000;
    receipt.cumulative_gas_used = 50000;
    receipt.status = RECEIPT_STATUS_SUCCESSFUL;

    const cloned = try receipt.clone(testing.allocator);
    defer {
        var mut_cloned = cloned;
        mut_cloned.deinit(testing.allocator);
    }

    try testing.expectEqual(receipt.gas_used, cloned.gas_used);
    try testing.expectEqual(receipt.cumulative_gas_used, cloned.cumulative_gas_used);
    try testing.expectEqual(receipt.status, cloned.status);
}
